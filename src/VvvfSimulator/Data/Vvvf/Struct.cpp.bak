#include "Struct.hpp"

// Standard Library
#include <algorithm>
#include <sstream>

namespace VvvfSimulator::Data::Vvvf
{
	void Struct::sortAcceleratePattern(bool inverse)
	{
		std::sort(acceleratePattern.begin(), acceleratePattern.end(),
			[inverse](const PulseControl& a, const PulseControl& b) {
				return inverse ? 
					(a.controlFrequencyFrom < b.controlFrequencyFrom) :
					(a.controlFrequencyFrom > b.controlFrequencyFrom);
			});
	}

	void Struct::sortBrakingPattern(bool inverse)
	{
		std::sort(brakingPattern.begin(), brakingPattern.end(),
			[inverse](const PulseControl& a, const PulseControl& b) {
				return inverse ? 
					(a.controlFrequencyFrom < b.controlFrequencyFrom) :
					(a.controlFrequencyFrom > b.controlFrequencyFrom);
			});
	}

	bool Struct::hasCustomPwm() const
	{
		auto hasCustom = [](const PulseControl& pc) {
			using PT = PulseControl::Pulse::PulseTypeName;
			return pc.pulseMode.pulseType == PT::CHM || 
			       pc.pulseMode.pulseType == PT::SHE;
		};

		return std::any_of(acceleratePattern.begin(), acceleratePattern.end(), hasCustom) ||
		       std::any_of(brakingPattern.begin(), brakingPattern.end(), hasCustom);
	}

	std::string Struct::toString() const
	{
		std::ostringstream oss;
		oss << "Vvvf::Struct { "
		    << "Level: " << level
		    << ", AccelPatterns: " << acceleratePattern.size()
		    << ", BrakePatterns: " << brakingPattern.size()
		    << ", HasCustomPwm: " << (hasCustomPwm() ? "true" : "false")
		    << " }";
		return oss.str();
	}
}
/*
   Copyright Â© 2025 VvvfGeeks, VVVF Systems
   
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

// Data/Vvvf/Analyze.cpp
// Version 1.10.0.0

#include "Analyze.hpp"
#include <algorithm>
#include <cmath>

namespace VvvfSimulator::Data::Vvvf {

template<typename TPattern>
std::optional<TPattern> Analyze::findCurrentPattern(
    const std::vector<TPattern>& patterns,
    double controlFrequency
) {
    if (patterns.empty()) {
        return std::nullopt;
    }

    // Find the pattern that applies to this control frequency
    // Patterns should be sorted by frequency
    for (auto it = patterns.rbegin(); it != patterns.rend(); ++it) {
        if (controlFrequency >= it->controlFrequencyFrom) {
            return *it;
        }
    }

    // If no pattern found, return the first one
    return patterns.front();
}

ControlFrequencyData Analyze::getControlFrequencyData(
    const Struct& vvvfStruct,
    double controlFrequency
) {
    ControlFrequencyData data;

    // Get current patterns
    auto accelPattern = getCurrentAcceleratePattern(vvvfStruct, controlFrequency);
    auto brakePattern = getCurrentBrakingPattern(vvvfStruct, controlFrequency);

    // Set control data based on current pattern
    if (accelPattern) {
        data.waveForm = accelPattern->control.waveForm;
        data.amplitude = accelPattern->control.amplitude;
        data.carrierFrequency = accelPattern->control.carrierFrequency;
        data.dipolar = accelPattern->control.dipolar;
        data.pulseMode = accelPattern->control.pulseMode;
    } else if (brakePattern) {
        data.waveForm = brakePattern->control.waveForm;
        data.amplitude = brakePattern->control.amplitude;
        data.carrierFrequency = brakePattern->control.carrierFrequency;
        data.dipolar = brakePattern->control.dipolar;
        data.pulseMode = brakePattern->control.pulseMode;
    } else {
        // Default values
        data.waveForm = WaveForm::Sine;
        data.amplitude = 0.0;
        data.carrierFrequency = 0.0;
        data.dipolar = 3;
        data.pulseMode = PulseMode::PWM;
    }

    return data;
}

std::optional<AcceleratePattern> Analyze::getCurrentAcceleratePattern(
    const Struct& vvvfStruct,
    double controlFrequency
) {
    return findCurrentPattern(vvvfStruct.acceleratePattern, controlFrequency);
}

std::optional<BrakingPattern> Analyze::getCurrentBrakingPattern(
    const Struct& vvvfStruct,
    double controlFrequency
) {
    return findCurrentPattern(vvvfStruct.brakingPattern, controlFrequency);
}

double Analyze::getFreeRunFrequency(
    const Struct& vvvfStruct,
    double controlFrequency
) {
    // Free run frequency calculation
    auto accelPattern = getCurrentAcceleratePattern(vvvfStruct, controlFrequency);
    if (accelPattern && accelPattern->control.freeRunOption.enable) {
        return controlFrequency * accelPattern->control.freeRunOption.sineFrequencyMultiplier;
    }

    auto brakePattern = getCurrentBrakingPattern(vvvfStruct, controlFrequency);
    if (brakePattern && brakePattern->control.freeRunOption.enable) {
        return controlFrequency * brakePattern->control.freeRunOption.sineFrequencyMultiplier;
    }

    return controlFrequency;
}

double Analyze::getMinimumFrequency(const Struct& vvvfStruct) {
    double minFreq = 0.0;

    if (!vvvfStruct.acceleratePattern.empty()) {
        minFreq = vvvfStruct.acceleratePattern.front().controlFrequencyFrom;
    }

    if (!vvvfStruct.brakingPattern.empty()) {
        double brakeMin = vvvfStruct.brakingPattern.front().controlFrequencyFrom;
        if (minFreq == 0.0 || brakeMin < minFreq) {
            minFreq = brakeMin;
        }
    }

    return minFreq;
}

double Analyze::getMaximumFrequency(const Struct& vvvfStruct) {
    double maxFreq = 0.0;

    if (!vvvfStruct.acceleratePattern.empty()) {
        // Find max control frequency from all patterns
        for (const auto& pattern : vvvfStruct.acceleratePattern) {
            if (pattern.controlFrequencyFrom > maxFreq) {
                maxFreq = pattern.controlFrequencyFrom;
            }
        }
    }

    if (!vvvfStruct.brakingPattern.empty()) {
        for (const auto& pattern : vvvfStruct.brakingPattern) {
            if (pattern.controlFrequencyFrom > maxFreq) {
                maxFreq = pattern.controlFrequencyFrom;
            }
        }
    }

    return maxFreq;
}

bool Analyze::requiresCustomPwm(
    const Struct& vvvfStruct,
    double controlFrequency
) {
    auto data = getControlFrequencyData(vvvfStruct, controlFrequency);
    return data.pulseMode == PulseMode::CHM || data.pulseMode == PulseMode::SHE;
}

double Analyze::getAmplitude(
    const Struct& vvvfStruct,
    double controlFrequency
) {
    auto data = getControlFrequencyData(vvvfStruct, controlFrequency);
    return data.amplitude;
}

PulseMode Analyze::getPulseMode(
    const Struct& vvvfStruct,
    double controlFrequency
) {
    auto data = getControlFrequencyData(vvvfStruct, controlFrequency);
    return data.pulseMode;
}

double Analyze::getCarrierFrequency(
    const Struct& vvvfStruct,
    double controlFrequency
) {
    auto data = getControlFrequencyData(vvvfStruct, controlFrequency);
    return data.carrierFrequency;
}

bool Analyze::isAsyncMode(
    const Struct& vvvfStruct,
    double controlFrequency
) {
    auto accelPattern = getCurrentAcceleratePattern(vvvfStruct, controlFrequency);
    if (accelPattern && accelPattern->control.asyncControl.enable) {
        return true;
    }

    auto brakePattern = getCurrentBrakingPattern(vvvfStruct, controlFrequency);
    if (brakePattern && brakePattern->control.asyncControl.enable) {
        return true;
    }

    return false;
}

int Analyze::getDipolar(
    const Struct& vvvfStruct,
    double controlFrequency
) {
    auto data = getControlFrequencyData(vvvfStruct, controlFrequency);
    return data.dipolar;
}

} // namespace VvvfSimulator::Data::Vvvf
// Merged from Analyze.cpp
